\chapter{Case studies}

\section{Explication through elimination}

This section will illustrate how we implement key features of technical computing
systems using our methodology.

\subsection{Conversion and comparison}

Type conversion provides a classic example of a binary method. Multiple
dispatch allows us to avoid deciding whether the converted-to type or the
converted-from type is responsible for defining the operation.
Defining a specific conversion is straightforward, and might look like this
in Julia syntax:

\begin{verbatim}
convert(::Type{Float64}, x::Int32) = ...
\end{verbatim}

\noindent
A call to this method would look like \texttt{convert(Float64, 1)}.

Using conversion in generic code requires more sophisticated definitions.
For example we might need to convert one value to the type of another,
by writing \texttt{convert(typeof(y), x)}. What set of definitions must
exist to make that call work in all reasonable cases? Clearly we cannot
explicitly write all $O(n^2)$ possibilities. We need abstract definitions
that cover many points in the dispatch matrix. One such family of points
is particularly important: those that describe converting a value to a
type it is already an instance of. In our system this can be handled by
a single definition that performs ``triangular'' dispatch:

\begin{verbatim}
convert{T}(::Type{T}, x::T) = x
\end{verbatim}

\noindent
``Triangular'' refers to the rough shape of the dispatch matrix covered
by such a definition: for all types \texttt{T} in the first argument slot,
match any type less than it in the second argument slot.


- The abstractions of equality and comparison. Different equivalence classes between

is/===, isequal and ==

- Numeric vs lexicographic ordering?

cmp, lexcmp, vs isless, <

\subsection{Numeric types and embeddings}

We might prefer ``number'' to be a single,
concrete concept, but the history of mathematics has seen the concept
extended many times, from integers to rationals to reals, and then to complex,
quaternion, and more. These constructions tend to follow a pattern: a new set
of numbers is constructed around a subset isomorphic to an existing set of
numbers. For example, the reals are isomorphic to the complex numbers with
zero imaginary part.

Human beings happen to be good at equating and moving between isomorphic sets,
so it is easy to imagine that the reals and complexes with zero imaginary
part are one and the same. But a computer forces us to be specific, and admit
that a real number is not complex, and a complex number is not real. And yet
the close relationship between them is too compelling not to model in a
computer somehow. Here we have a numerical analog to the famous ``circle and
ellipse'' problem in object-oriented programming: the set of circles is
isomorphic to the set of ellipses with equal axes, yet neither ``is a''
relationship in a class hierarchy seems fully correct. An ellipse is not
a circle, and in general a circle cannot serve as an ellipse (for example,
the set of circles is not closed under the same operations that the set of
ellipses is, so a program written for ellipses might not work on circles).
This problem implies that a single built-in type hierarchy is not
sufficient: we want to model custom *kinds* of relationships between
types (e.g. ``can be embedded in'' in addition to ``is a'').

Two further problems should also be kept in mind. First, the natural isomorphisms
between sets of numbers might not be isomorphisms on a real computer. For example,
due to the behavior of floating-point arithmetic, an operation on complex numbers
with zero imaginary part might not give an answer equal to the same operation on
real numbers. Second, the contexts that demand use of one type of number or
another are often not easily described by type systems. The classic example is
square root (\texttt{sqrt}), whose result is complex for negative arguments.
Including a number's sign in its type is a possibility, but this quickly gets
out of hand --- should a type system attempt to prove a matrix symmetric before
we compute its eigenvalues? While we cannot offer a once-and-for-all solution
to these problems, we will show how the flexibility of our proposed mechanism
is useful for addressing them.

% ex: generic sum function accumulating result in at least
% double precision. just using +::T->T->T doesn't work.

\subsubsection{Implementing type embeddings}

Most functions are naturally implemented in the value domain, but some are
actually easier to implement in the type domain. One reason is that there
is a bottom element, which most data types lack.

\subsubsection{Diversity of number and number-like types in practice}

Originally, our reasons for implementing all numeric types at the library
level were not entirely practical. We had a principled opposition to
including such definitions in a compiler, and guessed that being able to
define numeric types would help ensure the language was ``powerful enough''.
However, defining numeric and number-like types and their interactions turns
out to be surprisingly useful. Once such types become easy to obtain,
people find more and more uses for them.

Ordinal types: Pointer, Char

Integer types: Int8, Int16, Int32, Int64, Int128, UInt8, UInt16, UInt32, UInt64, UInt128, BigInt

Floating point types: Float16, Float32, Float64, BigFloat
(Float128, double-double)

Fixed point: Fixed32{b}, Ufixed8, Ufixed16

Extensions: Complex, Quaternion, Interval, DualNumber

Number-like: Date, TimePeriod, DatePeriod, Color, (Units), DNA nucleotide type (bioseq.jl)
dates: different cardinal and ordinal behavior

musical notes

\subsubsection{Applications}

\emph{Ranges} illustrate an interesting application of type promotion.
A range data type, notated \texttt{a:s:b}, represents a sequence of values
starting at \texttt{a} and ending at \texttt{b}, with a distance of \texttt{s}
between elements (internally, this notation is translated to
\texttt{colon(a, s, b)}). Ranges seem simple enough, but a reliable,
efficient, and generic implementation is difficult to achieve.
We propose the following requirements:

\begin{itemize}
\item The start and stop values can be passed as different types, but internally
  should be of the same type.
\item Ranges should work with ordinal types, not just numbers (examples include
  characters, pointers, and calendar dates).
\item If any of the arguments is a floating-point number, a special
  \texttt{FloatRange} type designed to cope well with roundoff is returned.
\end{itemize}

In the case of ordinal types, the step value is naturally of a different type
than the elements of the range. For example, one may add 1 to a character to
get the ``next'' encoded character, but it does not make sense to add two
characters.

It turns out that the desired behavior can be achieved with six definitions:

First, given three floats of the same type we can construct a \texttt{FloatRange}
right away:

\begin{verbatim}
colon{T<:FloatingPoint}(start::T, step::T, stop::T) = FloatRange{T}(start, step, stop)
\end{verbatim}

Next, if \texttt{a} and \texttt{b} are of the same type and there are no floats,
we can construct a general range:

\begin{verbatim}
colon{T}(start::T, step, stop::T) = StepRange(start, step, stop)
\end{verbatim}

Now there is a problem to fix: if the first and last arguments are of some
non-floating-point numeric type, but the step is floating point, we want to
promote all arguments to a common floating point type. We must also do this
if the first and last arguments are floats, but the step is some other kind
of number:

\begin{verbatim}
colon{T<:Real}(a::T, s::FloatingPoint, b::T) = colon(promote(a,s,b)...)

colon{T<:FloatingPoint}(a::T, s::Real, b::T) = colon(promote(a,s,b)...)
\end{verbatim}

These two definitions are correct, but ambiguous: if the step is a float
of a different type than \texttt{a} and \texttt{b} both definitions are
equally applicable. We can add the following disambiguating definition:

\begin{verbatim}
colon{T<:FloatingPoint}(a::T, s::FloatingPoint, b::T) = colon(promote(a,s,b)...)
\end{verbatim}

All of these five definitions require \texttt{a} and \texttt{b} to be of the
same type. If they are not, we must promote just those two arguments, and leave
the step alone in case we are dealing with ordinal types:

\begin{verbatim}
colon{A,B}(a::A, s, b::B) = colon(convert(promote_type(A,B),a), s, convert(promote_type(A,B),b))
\end{verbatim}

This example shows that it is not always sufficient to have a built-in set of
``promoting operators''. Library functions like this \texttt{colon} need more
control.


\subsubsection{Current approaches}

Numbers tend to be among the most
complex features of a language. Numeric types usually need to be a special
case: in a typical language with built-in numeric types, describing their
behavior is beyond the expressive power of the language itself. For example,
in C arithmetic operators like \texttt{+} accept multiple types of arguments
(ints and floats), but no user-defined C function can do this (this situation
is of course improved in C++). In Python, a special arrangement is made for
\texttt{+} to call either an \texttt{\_\_add\_\_} or \texttt{\_\_radd\_\_} method,
effectively providing double-dispatch for arithmetic in a language that is
idiomatically single-dispatch.



\subsection{Multidimensional array indexing}

One-dimensional arrays are a simple and essential data structure found in
most programming languages. The multi-dimensional arrays required in
scientific computing, however, are a different beast entirely. Allowing
any number of dimensions entails a significant increase in complexity. Why?
The essential reason is that core properties of the data structure no
longer fit in a constant amount of space. The space needed to store the
sizes of the dimensions (the array shape) is proportional to the number
of dimensions. This does not seem so bad, but becomes a large problem
due to three additional facts.

% TODO: break up using enumerate
First, code that operates on the dimension
sizes needs to be highly efficient. Typically the overhead of a loop is
unacceptable, and such code needs to be fully unrolled. Second, in some
code the number of dimensions is a \emph{dynamic} property --- it is
only known at run time. Third, programs may wish to treat arrays with
different numbers of dimensions very differently. A vector (1d) might
have rather different behaviors than a matrix (2d) (for example, to
compute a norm). This kind of
behavior makes the number of dimensions a crucial part of program
semantics, preventing it from remaining a compiler implementation detail.

% TODO: break up using enumerate
These facts pull in different directions. The first fact asks for static
analysis. The second fact asks for run-time flexibility. The third fact asks
for dimensionality to be part of the type system, but partly determined
at run time (for example, via virtual method dispatch). Current approaches
choose a compromise. In some systems, the number of dimensions has a strict
limit (e.g. 3 or 4), so that separate classes for each case may be written
out in full. Other systems choose flexibility, and just accept that most
or all operations will be dynamically dispatched. Other systems might
provide flexibility only at compile time, for example a template library
where the number of dimensions must be statically known.

%% TODO: insert example of limited power of C++ array libraries

%% TODO: examples of systems limited to n==3

Whatever decision is made, rules must be defined for how various operators
act on dimensions. For now we will focus on indexing, since selecting
parts of arrays has particularly rich behavior with respect to
dimensionality. For example, if a single row or column of a matrix is
selected, does the result have one or two dimensions? Array implementations
prefer to invoke general rules to answer such questions. Such a rule might
say ``dimensions indexed with scalars are dropped'', or ``trailing
dimensions of size one are dropped'', or ``the rank of the result
is the sum of the ranks of the indexes'' (as in APL).

%%%
Our goal here is a bit unusual: we are not concerned with which rules
might work best, but merely with how they can be specified, so that
domain experts can experiment.

In fact different domains want different things. E.g. in images, each
dimension might be quite different, e.g. time vs. space vs. color,
so you don't want to drop or rearrange dimensions very often.
%%%

Here are our ground rules:

\begin{enumerate}
\item You can't manually implement the behavior inside the compiler
\item The compiler must be able to reasonably understand the program
\item The code must be reasonably easy to write
\end{enumerate}


How are such rules implemented? For a
language with built-in multidimensional arrays, the compiler will
analyze indexing expressions and determine an answer using hard-coded
logic.
% TODO: grab example from one of these compilers
However, this approach is not satisfying: we would rather
implement the behavior in libraries, so that different kinds of arrays
may be defined, or so that rules of similar complexity may be
defined for other kinds of objects. But these kinds of rules are
unusually difficult to implement in libraries. If a library writes out
its indexing logic using imperative code, the host language compiler
is not likely to be able to analyze it. Using compile-time abstracton
(templates) would provide better performance, but such libraries tend
to be difficult to write (and read), and the full complement of
indexing behavior expected by technical users strains the capabilities
of such systems.

% TODO: insert actual example of numpy

Our dispatch mechanism permits a novel solution. If a multiple dispatch
system supports variadic functions and argument ``splicing'' (the ability
to pass a structure of $n$ values as $n$ separate arguments to a function),
then indexing behavior can be defined as method signatures.

This solution is still a compromise among the factors outlined above,
but it is a new compromise that provides a net-better solution.
% TODO more

Below we define a function \texttt{index\_shape} that computes the
shape of a result array given a series of index arguments. We show
three versions, each implementing a different rule that users in
different domains might want:

% TODO: point out array = (shape, data), so those are the two parts
% we need to handle. In julia the ``data'' part is not a first class
% object; it is not directly exposed to the user, but this is more
% of an implementation detail.

\begin{verbatim}
# drop dimensions indexed with scalars
index_shape() = ()
index_shape(i::Real, I...) = index_shape(I...)
index_shape(i, I...) = tuple(length(i), index_shape(I...)...)
\end{verbatim}

\begin{verbatim}
# drop trailing dimensions indexed with scalars
index_shape(i::Real...) = ()
index_shape(i, I...) = tuple(length(i), index_shape(I...)...)
\end{verbatim}

\begin{verbatim}
# rank summing (APL)
index_shape() = ()
index_shape(i, I...) = tuple(size(i)..., index_shape(I...)...)
\end{verbatim}

Inferring the length of the result of \texttt{index\_shape} is sufficient
to infer the rank of the result array.

These definitions are concise, easy to write, and possible for a
compiler to understand fully using straightforward techniques.

% TODO: point out how this combines the ``object part'' and the
% ``array part'' into a coherent whole.

Here is a sample derivation for the call \texttt{index\_shape(1:m,1,1:n)}
(the argument type tuple is \texttt{(Range1,Int,Range1)}), using the first
definition above (dropping scalar-indexed dimensions):

\begin{verbatim}
index_shape(1:n, 1, 1:m) => tuple(length(::Range1)::Int, index_shape((::Int, ::Range1)...)...)

index_shape((::Int, ::Range1)...) => index_shape(::Int, ::Range1)

index_shape(::Int, ::Range1) => index_shape((::Range1,)...)

index_shape((::Range1,)...) => index_shape(::Range1)

index_shape(::Range1) => tuple(length(::Range1)::Int, index_shape(()...)...)

index_shape(()...) => index_shape()::()

back substitute => tuple(length(::Range1)::Int, index_shape(()...)::()...)::(Int,)

back substitute => tuple(length(::Range1)::Int, ::(Int,)...)

tuple(::Int, ::(Int,)...) => tuple(::Int, ::Int)

::(Int, Int)

\end{verbatim}

The result type is determined using only dataflow type inference, plus a
rule for splicing an immediate container (the type of \texttt{f((a,b)...)} is
the type of \texttt{f(a,b)}). Argument list destructuring takes place inside
the type intersection operator used to combine argument types with method
signatures.

This approach does not depend on any heuristics. Each call to \texttt{index\_shape}
simply requires one recursive invocation of type inference. This process reaches
the base case \texttt{()} for these definitions, since each recursive call
handles a shorter argument list (for less-well-behaved definitions, we might
end up invoking a widening operator instead).


\begin{verbatim}
diverge() = randbool() ? () : tuple(1, diverge()...)
\end{verbatim}

\subsection{Array views}

\subsection{Units}

\subsection{Even more elimination?}

Some features of the language could be even further eliminated. For example data
types could be implemented in terms of lambda abstractions. But certain patterns
are so useful that they might as well be provided in a standard form. It also
probably makes the compiler much more efficient not to need to pass around and
repeatedly analyze full representations of the meanings of such ubiquitous constructs.


\section{Numerical linear algebra}

Multiple dispatch on special matrices

29 LAPACK types via composition of 9 types, issue 8240


\section{Boundary-element method}

There are lots of general packages for FEM problems, but it is much more
difficult to create such a package for BEM problems. The method requires
integrating functions with singularities, many times in the inner loop
of code that builds the problem matrix. Integrating such functions
numerically on each iteration is much too slow. As a result, many
special-purpose implementations have been written by hand for different
problems.

Some recent work (TODO cite Homer) managed a more general solution,
using Mathematica to generate C++ code for different cases. This worked
well, but was difficult to implement and the resulting system is difficult
to use. We see the familiar pattern of using multiple languages and
code-generation techniques, with coordination of the overall process done
either manually or with ad-hoc scripts. To polish the implementation for
use as a practical library, a likely next step would be to add a Python
interface, adding yet another layer of complexity.


Features of julia this demonstrates:

- functions that need to dispatch on more than one argument
- staged methods providing a natural way to integrate code generation
- doing specialization through the object system, leading to a ``flat'' system

The code can be structured as a simple function library.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% writeup by SGJ

\subsection{Galerkin matrix assembly for singular kernels}

A typical problem in computational science is to form a discrete approximation of some infinite-dimensional linear operator $\mathcal{L}$ with some finite set of basis functions $\{ b_m \}$ via a Galerkin approach [refs], which leads to a matrix $L$ with entries $L_{mn} = \langle b_m, \mathcal{L} b_n \rangle = \langle b_m, b_n \rangle_\mathcal{L}$ where $\langle \cdot, \cdot \rangle$ denotes some inner product (e.g. $\langle u, v \rangle = \int u v$ is typical) and  $\langle \cdot, \cdot \rangle_\mathcal{L}$ is the \emph{bilinear form} of the problem.  Computing these matrix elements is known as the matrix \emph{assembly} step, and its performance is a crucial concern for solving partial differential equations (PDEs) and integral equations (IEs).

\subsubsection{The ``easy'' case: nonsingular assembly}

For example, in the finite-element method (FEM) [refs], the basis functions $b_m$ are typically low-order polynomials defined piecewise over geometric elements (typically triangles or tetrahedra), and $\mathcal{L}$ is typically a differential operator like $-\nabla \cdot c(x) \nabla$ for some coefficients $c(x)$, which leads to a bilinear form  $\langle b_m, b_n \rangle_\mathcal{L} = \int \nabla b_m \cdot c(x) \nabla b_n$ (after integration by parts).   Because the basis functions are localized and $\mathcal{L}$ consists of local operations, the matrix $L$ is sparse and $L_{mn}$ need only be computed for $m$ and $n$ corresponding to neighboring elements. Moreover, these integrals are straightforward to evaluate by standard cubature schemes because the integrands are \emph{nonsingular}: they typically have no divergences or discontinuities. In particular, because the functions $b_m$ and $c$ are usually smooth within a single element, one can use a fixed low-order cubature rule: you evaluate the integrand at a handful of precomputed points within each element, multiply by precomputed weights, and sum to obtain the approximate integral.

Even so, the basis functions and the coefficient function $c(x)$ may need to be evaluated tens of millions of times for even a moderate-size mesh in three dimensions, so production FEM implementations in traditional high-level dynamic languages such as Matlab and Python are forced to offload matrix assembly to external C and C++ code.  For example, the popular FEniCS [ref] and Firedrake [ref] FEM packages for Python both implement domain-specific compilers: a symbolic expression for the bilinear form is combined with fragments of user-specified C++ code to define functions like $c(x)$, compiled to C++ code, and then compiled to object code which is dynamically loaded. In Julia, we believe this could be simplified considerably because functions like $c(x)$ could be defined directly in Julia and code generation/compilation could be performed entirely within Julia without a C++ intermediary.  Indeed, preliminary experiments with pure Julia FEM implementations [ref http://www.codeproject.com/Articles/579983/Finite-Element-programming-in-Julia] have demonstrated performance comparable to sophisticated solutions like FEniCS in Python and FreeFem++ in C++ [ref]

\subsubsection{Singular assembly for integral operators}

A much more challenging case of Galerkin matrix assembly arises for
singular \emph{integral} operators $\mathcal{L}$, which act by
convolving their operand against a singular ``kernel'' function
$K(x)$: $u = \mathcal{L} v$ means that $u(x) = \int K(x - x') v(x')
dx'$.  For example, in electrostatics and other Poisson problems, the
kernel is $K(x) = 1/|x|$ in three dimensions and $\ln |x|$ in two
dimensions, while in scalar Helmholtz (wave) problems it is
$e^{ik|x|}/|x|$ in three dimensions and a Hankel function
$H^{(1)}_0(k|x|)$ in two dimensions.  Formally, Galerkin
discretizations lead to matrix assembly problems similar to those
above: $L_{mn} =: \langle b_m, \mathcal{L} b_n \rangle = \int b_m(x)
K(x - x') b_n(x') dx\,dx'$.  However, there are several important
differences from FEM:

\begin{itemize}

\item The kernel $K(x)$ nearly always diverges for $|x|=0$, which means that generic cubature schemes are either unacceptably inaccurate (for low-order schemes) or unacceptably costly (for adaptive high-order schemes, which require huge numbers of cubature points around the singularity), or both.

\item Integral operators typically arise for \emph{surface} integral
  equations (SIEs) [ref], and involve unknowns on a surface.  The
  analogue of the FEM discretization is then a boundary element method
  (BEM) [ref], which discretizes a surface into elements
  (e.g. triangles), with basis functions that are low-order
  polynomials defiend piecewise in the elements.  However, there are
  also volume integral equations (VIEs) which have FEM-like volumetric
  meshes and basis functions.

\item The matrix $L$ is typically dense, since $K$ is long-range.  For
  large problems, $L$ is often stored and applied implicitly via
  fast-multipole methods [refs] and similar schemes, but even in this
  case the diagonal $L_{mm}$ and the entries $L_{mn}$ for adjacent
  elements must typically be computed explicitly.  (Moreover, these
  are the integrals in which the $K$ singularity is present.)

\end{itemize}

These difficulties are part of the reason why there is currently \emph{no}
truly ``generic'' BEM software, analogous to FEniCS for FEM: essentially
all practical BEM code is written for a specific integral kernel and
a specific class of basis functions arising in a particular physical problem.
Changing anything about the kernel or the basis---for example, going
from two- to three-dimensional problems---is a major undertaking.

We believe that Julia should be an ideal platform on which to attack this
problem:

\begin{itemize}

\item Multiple dispatch allows the cubature scheme to be selected at compile-time based on the dimensionality, the degree of the singularity, the degree of the polynomial basis, and so on, and allows specialized schemes to be added easily for particular problems with no runtime penalty.

\item Staged functions allow computer-algebra systems to be invoked at
  compile-time to generate specialized cubature schemes for particular
  kernels.  New developments in BEM integration schemes [ref Homer] have
  provided efficient cubature-generation algorithms of this sort, but it
  has not yet been practical to integrate them with runtime code in
  a completely automated way.

\end{itemize}

A prototype implementation of this approach follows.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Dates}

compare to python DateTime, compare code length


\section{JUMP}

Metaprogramming tools reused for symbolic algebra


\section{Computational geometry}

robust predicates (dispatch over points, lines) and VoronoiDelaunay.jl
benchmarked against CGAL


\section{Beating the incumbents}

- erfinv and digamma using horner macro
- randn beating matlab

\texttt{@evalpoly} macro has separate cases for real and complex in order to
automatically take advantage of a subtle algorithm (TODO cite TAOCP).
A macro is perfect for generating the neccessary code, however it lacks
the type information needed to select between the two cases.
In Julia, it can generate a branch with a type check, and rely on the
unused case being removed by automatic specialization. (A generic
function with two definitions could be generated instead, but in
high-performance programming the ``force inlining'' behavior of macros
is welcome.)

If nothing else, demonstrates that removing glue code overhead is worthwhile.

grisu: 6kLOC to 1kLOC (PR 7291)


\section{misc staged functions}

tim holy in issue 8839:

``without staged functions in my initial post in 8235. The take-home message: generating all methods through dimension 8 resulted in more than 5000 separate methods, and required over 4 minutes of parsing \& lowering time (i.e., a 4-minute delay while compiling julia). By comparison, the stagedfunction implementation loads in a snap, and of course can go even beyond 8 dimensions.''


%\section{ACAS}

%\section{Parallel computing, e.g. parallel prefix}

%\section{IJulia}
