\chapter{Conclusion}

%Here is a snapshot of Julia in April, 2014

%Show all the stuff that will be fun to look at because it\textquoteright{}ll
%be so antiquated by 2019

%by following this kind of approach computer scientists can have it
%both ways, and make new interesting things that are also immediately
%useful.

% to what extent is this a technical computing language?
% it's not, really :)

``I've yet to hear anyone explain how you decide what are the boundaries of a `domain-specific' language. Isn't the `domain' mathematics and science itself?''~\cite{bobharperdsl}

% something about how ``information hiding'' is anathema to science,
% and coincidentally is not the focus of t.c. languages or rigorous
% functional languages.

% \cite{meyerovich2012socio} about appealing to some domain first

A generation of dynamic languages have been designed by trying variants of
the class-based object oriented paradigm. This process has been aided by
the development of standard techniques (e.g. bytecode VMs) and reusable
infrastructure such as code generators, garbage collectors, and whole VMs
like the JVM and CLR.

It is possible to envision a future generation of languages that generalize
this design to set-theoretic subtyping instead of just classes. This next
generation will require its own new tools, such as partial evaluators (already
under development in PyPy and Truffle). One can also imagine these future
language designers wanting reusable program analyses, and tools for
developing lattices and their operators.

% actually not enough is done with dynamic typing: you give up type
% checking, and all you get is untyped dictionaries in return?

Julia encourages lattice-theoretic execution models to become integral
parts of languages. dispatch was an especially natural way to do this,
are there others?
% talk about partial information
% somehow being dual to ML-family languages; what's hard for them is
% easy for us and vice versa.

It is interesting to observe that the data model of a language like Julia
consists of two key relations: the subtype relation, which is relatively
well understood and enjoys useful properties like transitivity, but also
the typeof relation, which relates individual values to their types
(i.e. the `typeof` function). The typeof relation appears not to be
transitive, and also has a degree of arbitrariness: a value is of a type
merely because it is labeled as such, and because various bits of code
conspire to ensure that this labeling makes sense according to various
criteria.

We have speculated about whether future languages will be able to do away
with this distinction. One approach is $\lambda_{\aleph}$. We have also
speculated that this could be done using types based on non-well-founded
set theory, combining the subset-of and element-of relations using
self-containing sets. We are not yet sure what a practical language based
on this idea might look like.


There are several key aspects of performance programming that our design
does not directly address, e.g.  storage and in-place optimizations.

future work:
product domains

how to incorporate finer types more smoothly


% steve j suggestions:
% Precompilation?  Issues with type-inference?  Inlining anonymous functions?
% \section{Separate compilation}
% Technically julia does not support it, but that's never stopped anybody
% from doing it anyway. e.g. C++

% oscar:
% - what we have now is the ``minimal julia''
% - ``easy to write code that's easy to analyze statically''
% - got non-programmer people to write easy to analyze code
%   - bad that they need to think about type stability, but
%     also good that is relatively easy to grasp, and it gets
%     people thinking about it who wouldn't normally
%     - the types give people the tools to deal with it
% - can't pretend that people wont have to worry about this stuff;
%   it's fundamental

% mention lines of code
%% How much of the past 30 years of handwritten Matlab internals can
%% be autogenerated with a compiler? (A lot)

% we know these programs need more organization and type info.
% this is the first truly viable approach

% easy polymorphism.
% - starts with a very simple HLL
% - performs well because of underlying mechanisms,
%   which then unfold gradually when you want more control over performance

% making everything a method, and everything glued together by types
% gives certain reflective properties.

% issues
% - static comp, separate comp
% - functions
% - static typing, TypeCheck.jl
